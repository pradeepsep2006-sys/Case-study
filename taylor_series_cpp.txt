#include <iostream>
#include <cmath>
#include <iomanip>
#include <string>
#include <vector>
using namespace std;
class TaylorSeries {
protected:
    double x;
    int n;
    virtual long long factorial(int num) const {
        if (num <= 1) return 1;
        long long result = 1;
        for (int i = 2; i <= num; i++) {
            result *= i;
        }
        return result;
    }   
public:
    TaylorSeries(double value, int terms) : x(value), n(terms) {}
    virtual ~TaylorSeries() {}
    virtual double compute() const = 0;
    virtual string getName() const = 0;
    double getValue() const { return x; }
    int getTerms() const { return n; }
    void display() const {
        cout << fixed << setprecision(10);
        cout << getName() << "(" << x << ") with " << n << " terms = " 
             << compute() << endl;
    }
};
class ExponentialSeries : public TaylorSeries {
public:
    ExponentialSeries(double value, int terms) : TaylorSeries(value, terms) {}
    
    double compute() const override {
        double result = 1.0;
        double term = 1.0;
        
        for (int i = 1; i < n; i++) {
            term *= x / i;
            result += term;
        }
        return result;
    }
    
    string getName() const override {
        return "e^x";
    }
};
class SineSeries : public TaylorSeries {
public:
    SineSeries(double value, int terms) : TaylorSeries(value, terms) {}
    
    double compute() const override {
        double result = 0.0;
        double term = x;
        
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                result += term;
            } else {
                result -= term;
            }
            term *= x * x / ((2 * i + 2) * (2 * i + 3));
        }
        return result;
    }
    
    string getName() const override {
        return "sin(x)";
    }
};
class CosineSeries : public TaylorSeries {
public:
    CosineSeries(double value, int terms) : TaylorSeries(value, terms) {}
    
    double compute() const override {
        double result = 0.0;
        double term = 1.0;
        
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                result += term;
            } else {
                result -= term;
            }
            term *= x * x / ((2 * i + 1) * (2 * i + 2));
        }
        return result;
    }
    
    string getName() const override {
        return "cos(x)";
    }
};
class TaylorCalculator {
private:
    vector<TaylorSeries*> seriesList;
    
    double getActualValue(const TaylorSeries* series) const {
        string name = series->getName();
        double x = series->getValue();
        
        if (name == "e^x") {
            return exp(x);
        } else if (name == "sin(x)") {
            return sin(x);
        } else if (name == "cos(x)") {
            return cos(x);
        }
        return 0.0;
    } 
public:
    TaylorCalculator() {}
    
    ~TaylorCalculator() {
        for (auto series : seriesList) {
            delete series;
        }
    }
    
    void addSeries(TaylorSeries* series) {
        seriesList.push_back(series);
    }
    
    void calculateAll() const {
        cout << fixed << setprecision(10);
        
        for (size_t i = 0; i < seriesList.size(); i++) {
            cout << "\n--- Calculation " << (i + 1) << " ---" << endl;
            
            TaylorSeries* series = seriesList[i];
            double computed = series->compute();
            double actual = getActualValue(series);
            
            cout << series->getName() << "(" << series->getValue() 
                 << ") with " << series->getTerms() << " terms:" << endl;
            cout << "Approximation: " << computed << endl;
            cout << "Actual value:  " << actual << endl;
            cout << "Error:         " << fabs(computed - actual) << endl;
        }
    }
    void displayResults() const {
        cout << fixed << setprecision(10);
        cout << "\n=== Taylor Series Results ===" << endl;
        
        for (auto series : seriesList) {
            series->display();
        }
    }
};
class TaylorDemo {
public:
    static void runBasicExamples() {
        cout << "=== Taylor Series Approximation (OOP Implementation) ===" << endl;
        cout << "\nBasic Examples:\n" << endl;
        
        ExponentialSeries exp1(1.0, 10);
        cout << "Example 1: ";
        exp1.display();
        
        SineSeries sin1(M_PI/4, 10);
        cout << "Example 2: ";
        sin1.display();
        
        CosineSeries cos1(M_PI/3, 10);
        cout << "Example 3: ";
        cos1.display();
    }
    
    static void runPolymorphismDemo() {
        cout << "\n\n=== Polymorphism Demo ===" << endl;
        
        vector<TaylorSeries*> functions;
        functions.push_back(new ExponentialSeries(0.5, 8));
        functions.push_back(new SineSeries(M_PI/6, 8));
        functions.push_back(new CosineSeries(0.0, 8));
        
        for (size_t i = 0; i < functions.size(); i++) {
            cout << "\nFunction " << (i + 1) << ": ";
            functions[i]->display();
            delete functions[i];
        }
    }
    static void runCalculatorDemo() {
        cout << "\n\n=== Calculator Demo (Composition) ===" << endl;
        
        TaylorCalculator calc;
        
        calc.addSeries(new ExponentialSeries(1.0, 15));
        calc.addSeries(new SineSeries(M_PI/2, 15));
        calc.addSeries(new CosineSeries(M_PI/4, 15));
        
        calc.calculateAll();
    }
};
int main() {
    TaylorDemo::runBasicExamples();
    TaylorDemo::runPolymorphismDemo();
    TaylorDemo::runCalculatorDemo();
    
    cout << "\n\nProgram completed successfully!" << endl;
    
    return 0;
}